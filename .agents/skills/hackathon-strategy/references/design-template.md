# 設計テンプレート - ハッカソン高速版

ハッカソン向けに最適化されたアーキテクチャ設計テンプレート。30分以内に技術設計を完了させる。

## 目次

1. [高速アーキテクチャ設計](#高速アーキテクチャ設計)
2. [Gemini 3 統合設計パターン](#gemini-3-統合設計パターン)
3. [フロントエンド設計ガイド](#フロントエンド設計ガイド)
4. [データフロー設計](#データフロー設計)
5. [デプロイ戦略](#デプロイ戦略)
6. [チーム分担テンプレート](#チーム分担テンプレート)

---

## 高速アーキテクチャ設計

### 設計テンプレート

```markdown
# [プロジェクト名] - 技術設計書

## 1. アーキテクチャ概要

### 1.1 システム構成図

[ここにMermaid図やASCII図を描く]

例:
┌─────────┐    ┌──────────┐    ┌──────────────┐
│  Client  │───▶│  API     │───▶│  Gemini 3    │
│ (Next.js)│◀───│  Server  │◀───│  API         │
└─────────┘    └──────────┘    └──────────────┘
                    │
                    ▼
               ┌──────────┐
               │  Storage  │
               │  (任意)   │
               └──────────┘

### 1.2 技術スタック

| レイヤー | 技術 | 選定理由 |
|---------|------|---------|
| フロントエンド | Next.js + Tailwind | 高速UI構築、SSR対応 |
| バックエンド | Next.js API Routes | フロントと同一リポジトリ |
| AI | Gemini 3 API | ハッカソン要件 |
| エージェント | Antigravity | Google公式 |
| デプロイ | Vercel | 最速デプロイ (git push) |
| データストア | [選択] | [理由] |

### 1.3 主要API設計

| エンドポイント | メソッド | 入力 | 出力 | Gemini 3使用 |
|---------------|---------|------|------|-------------|
| /api/analyze | POST | image, text | analysis JSON | Yes |
| /api/generate | POST | prompt, context | generated content | Yes |
| /api/[other] | POST | [params] | [response] | Yes/No |

## 2. Gemini 3 統合設計

### 2.1 プロンプト設計

#### システムプロンプト
[具体的なシステムプロンプトを記載]

#### ユーザープロンプトテンプレート
[変数を含むプロンプトテンプレート]

### 2.2 入出力設計

入力:
- テキスト: [形式・制限]
- 画像: [形式・サイズ制限]
- その他: [必要に応じて]

出力:
- 形式: JSON / テキスト / ストリーミング
- スキーマ: [JSON Schemaがあれば]

### 2.3 エラーハンドリング

| エラー | ユーザーへの表示 | 内部処理 |
|--------|----------------|---------|
| API タイムアウト | "少々お待ちください..." | リトライ (最大3回) |
| レート制限 | "混雑中です" | キューイング |
| 不適切な応答 | "もう一度お試しください" | ログ記録、リトライ |

## 3. フロントエンド設計

### 3.1 画面一覧

| 画面 | パス | 主要コンポーネント | MVP? |
|------|------|-------------------|------|
| ホーム | / | Hero, CTA | Yes |
| メイン機能 | /app | [メイン画面] | Yes |
| 結果表示 | /result | [結果画面] | Yes |

### 3.2 状態管理

[React Context / Zustand / URL State のいずれかを選択]

### 3.3 レスポンシブ対応

MVP: デスクトップのみ (デモは大画面)
Stretch: モバイル対応

## 4. 実装タスク分解

### Phase 1: 基盤 (0:00-1:00)
- [ ] プロジェクトセットアップ
- [ ] Gemini 3 API接続確認
- [ ] 基本UIスケルトン

### Phase 2: コア機能 (1:00-4:00)
- [ ] [機能1] 実装
- [ ] [機能2] 実装
- [ ] [機能3] 実装

### Phase 3: 統合・改善 (4:00-6:00)
- [ ] 全機能統合
- [ ] UI/UX改善
- [ ] エラーハンドリング

### Phase 4: デモ準備 (6:00-7:30)
- [ ] デモデータ準備
- [ ] デモシナリオ確認
- [ ] バックアップ動画撮影

### Phase 5: 最終調整 (7:30-8:00)
- [ ] 最終テスト
- [ ] プレゼン練習
```

---

## Gemini 3 統合設計パターン

### Pattern A: シンプルリクエスト-レスポンス

```
最もシンプル。1回のAPI呼び出しで完結。

[User] → [Your App] → [Gemini 3] → [Your App] → [User]

適用場面:
- テキスト分析
- 画像認識
- 翻訳
- 要約

実装難易度: ★☆☆☆☆
デモ映え: ★★☆☆☆
```

### Pattern B: チェーンドプロンプト

```
複数のGemini 3呼び出しを連鎖させる。

[Input] → [Gemini: 分析] → [Gemini: 生成] → [Gemini: 評価] → [Output]

適用場面:
- 高品質なコンテンツ生成
- 段階的な推論
- 自己改善ループ

実装難易度: ★★☆☆☆
デモ映え: ★★★☆☆
```

### Pattern C: ファンアウト-ファンイン

```
入力を複数の観点で並列分析し、結果を統合。

              ┌→ [Gemini: 視点A] ─┐
[Input] ──────┼→ [Gemini: 視点B] ─┼→ [統合] → [Output]
              └→ [Gemini: 視点C] ─┘

適用場面:
- 多角的分析
- A/Bテスト
- 複数ペルソナでの評価

実装難易度: ★★★☆☆
デモ映え: ★★★★☆
```

### Pattern D: エージェンティック

```
Gemini 3がツールを使いながら自律的にタスクを実行。

[Goal] → [Gemini Agent] ←→ [Tool1: Web検索]
                        ←→ [Tool2: データベース]
                        ←→ [Tool3: 計算]
         → [Result]

適用場面:
- 複雑なタスクの自動実行
- 調査・分析
- マルチステップワークフロー

実装難易度: ★★★★☆
デモ映え: ★★★★★
```

### Pattern E: リアルタイムストリーミング

```
入力を連続的に処理し、リアルタイムでフィードバック。

[Continuous Input] ──stream──→ [Gemini 3] ──stream──→ [Real-time Output]

適用場面:
- ライブ解説
- リアルタイムコーチング
- チャット

実装難易度: ★★★☆☆
デモ映え: ★★★★★
```

---

## フロントエンド設計ガイド

### ハッカソンで映えるUI設計のコツ

1. **ダークモード推奨**: プロジェクターでも見やすく、モダンに見える
2. **大きなフォント**: 会場の後ろからも見える (最小16px、見出し24px+)
3. **アニメーション**: ローディング中のスケルトンUI、スムーズなトランジション
4. **カラースキーム**: 2-3色に限定 (ブランドカラー + アクセント)

### 推奨コンポーネントライブラリ

| ライブラリ | 特徴 | セットアップ時間 |
|-----------|------|----------------|
| shadcn/ui | 高品質、カスタマイズ可能 | 10分 |
| Headless UI | アクセシブル、軽量 | 5分 |
| Radix UI | プリミティブ、柔軟 | 10分 |

### 最小画面構成

```
┌───────────────────────────────────────┐
│  Header: [ロゴ] [プロジェクト名]       │
├───────────────────────────────────────┤
│                                       │
│  Main Area:                           │
│  ┌─────────────────┐ ┌─────────────┐ │
│  │                 │ │             │ │
│  │  Input Area     │ │  Output     │ │
│  │  (テキスト/     │ │  Area       │ │
│  │   画像アップ    │ │  (結果表示) │ │
│  │   ロード)       │ │             │ │
│  │                 │ │             │ │
│  └─────────────────┘ └─────────────┘ │
│                                       │
├───────────────────────────────────────┤
│  Footer: [Powered by Gemini 3]        │
└───────────────────────────────────────┘
```

---

## データフロー設計

### 典型的なデータフロー

```
1. ユーザー入力
   └→ クライアントバリデーション
      └→ API Route (Next.js)
         └→ 前処理 (画像リサイズ等)
            └→ Gemini 3 API コール
               └→ レスポンス解析
                  └→ 後処理 (フォーマット等)
                     └→ クライアントへ返却
                        └→ UI更新
```

### 状態管理設計

```typescript
// 推奨: シンプルな状態管理
interface AppState {
  // 入力
  input: string | File | null;

  // 処理状態
  isLoading: boolean;
  error: string | null;

  // 出力
  result: Result | null;

  // 履歴 (オプション)
  history: HistoryItem[];
}
```

---

## デプロイ戦略

### Vercel (推奨: 最速)

```bash
# 1. Vercel CLIインストール
npm i -g vercel

# 2. デプロイ (1コマンド)
vercel --prod

# 3. 環境変数設定
vercel env add GOOGLE_API_KEY
```

**メリット**: git pushでデプロイ、SSL自動、CDN付き
**デメリット**: サーバーレスの制約 (実行時間制限)

### Cloud Run (バックエンド重い場合)

```bash
# Dockerfile が必要
gcloud run deploy my-app --source .
```

**メリット**: コンテナベース、制約が少ない
**デメリット**: セットアップに時間がかかる

### 推奨戦略

```
MVP: Vercel (フロント + API Routes)
スケール: Vercel (フロント) + Cloud Run (バックエンド)
```

---

## チーム分担テンプレート

### 2人チーム

```
Person A: フロントエンド + デモ準備
Person B: バックエンド + Gemini 3統合

共同: 要件定義、設計、プレゼン
```

### 3人チーム

```
Person A: フロントエンド (UI/UX)
Person B: バックエンド + API設計
Person C: Gemini 3統合 + プロンプトエンジニアリング

共同: 要件定義、設計
プレゼン: 最もプレゼンが上手い人
```

### 4人チーム

```
Person A: フロントエンド (UI/UX)
Person B: バックエンド + API設計
Person C: Gemini 3統合 + エージェント設計
Person D: データ + テスト + デモ準備

共同: 要件定義、設計
プレゼン: 最もプレゼンが上手い人
```

### 分担の鉄則

1. **全員がコア機能を理解している**: 誰が欠けてもデモできる状態
2. **2時間ごとに統合**: 各自の作業を結合してテスト
3. **ブロッカーは即座に共有**: 15分詰まったら相談
4. **最後の1時間は全員でデモ準備**: 実装終了のデッドラインを厳守
